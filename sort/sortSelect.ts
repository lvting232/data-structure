/**
 * 选择排序的基本思想：
 * 每一趟在待排序的记录中选出关键字最小的记录，依次存放在已拍好序的记录序列的最后，直到全部记录排序完为止
 * 一般有直接排序和堆排序
 */


/**
 * 直接选择排序
 * 每次从待排序的无序区中选择出关键字值最小的记录，将该记录与该区中的第一个记录交换位置。
 * 初始时，R[1...n]为无序区，有序区为空。
 * 第一趟排序是在无序区R[1...n]中选出最小的记录，将他和R[1]交换，R[1]为有序区
 * 第二趟排序是在无序区R[2...n]中选出最小的记录与R[2]交换，此时R[1..2]为有序区；
 * 依次做n-1趟排序后，区间R[1...n]记录按递增有序
 * 
 * 非稳定性排序 O(n^2)
 */

const array1 = [2312,124,124,21,23,124,5125,421414,2];


function demo1() {
    function selectSort(array) {
        const len = array.length;
        let temp;
        for (let i = 0; i< len; i++) {
            let k = i;
            for (let j= i+1; j< len; j++) {
                if (array[j] < array[k]) {
                    k= j;
                }
                if (k !== i) {
                    temp = arr[i];
                    arr[i] = arr[k]
                    arr[k] = temp;
                }
            }
        }
    }
}

/**
 * 堆排序 是一种树形选择排序，基本思想是
 * 在排序过程中，将记录数组R[1..n]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系，
 * 在当前无序区中选择关键字最大（或最小）的记录
 * 堆的定义如下：n个记录的关键字序列k1, k2, ..., kn称为堆，当且仅当满足以下关系
 * ki <= k2i 且 ki <= k2i+1,或 ki>= k2i 且 ki>= k2i+1 (1 <= i <= [n/2])
 * 前者称为小根堆，后者称为大根堆。
 * [76, 38, 59, 27, 15, 44] 就是一个大根堆
 * [15, 27, 44, 76, 38, 59] 小根堆
 * 堆排序就是利用大根堆（小根堆）来选取当前无序区中关键字最大（最小）的记录实现排序的。
 * 每一趟的排序操作是：
 * 将当前无序区调整为一个大根堆，选取关键字最大的堆顶记录，将他和无序区中最后一个记录交换，这正好与选择排序相反。
 * 堆排序就是一个不断建堆的过程。
 * 
 * 如何构造堆？ 
 * 把待排序的文件的关键字存放在数组R[1..n]中，将R看做一颗完全二叉树的存储结构，每个结点表示一个记录，
 * 源文件的第一个记录R[1]作为二叉树的根，以下个记录R[2...n]依次逐层从左到右顺序排列，构成一颗完全二叉树。
 * 任意结点R[i]的左孩子是R[2i]，右孩子是R[2i+1]，双亲是R[i/2]
 * 在这里，假设构建的是大根堆：加入完全二叉树的某一节点i左子树、右子树都是堆，只需要将R[2i]和R[2i+1]中比较大的与R[i]对比，
 * 如果R[i]较小则交换，这样有可能破坏下一级的堆，所采用上述方式构造下一级的堆，直到完全二叉树中以i为根的子树成为堆。
 * 
 * !!!这一块的实现有问题!!!
 * 
 */
const arraySelect = [3,2131,23,12,412412,2];
/**
 * 构建大根堆 
 */
function sift(arr, i, h) {
    let j = 2 * i;
    let x = arr[i];
    while (j <= h) {
        if (j< h && arr[j] < arr[j+1]) {
            j++;
        }
        if (x >= arr[j])
            break;
        arr[i] = arr[j];
        i = j;
        j = 2*i;
    }
    arr[i] = x;
}

function heapSort(arr) {
    const len = arr.length;
    for (let i= Math.ceil(len / 2); i> 0; i--) {
        sift(arr, i, len);
    }
    for (let i= len; i> 0; i--) {
        let temp = arr[1];
        arr[1] = arr[i];
        arr[i] = temp;
        sift(arr, 1, i-1);
    }
}
